#encoding: utf-8

class Store < ActiveRecord::Base

  store :settings, accessors: [
    :locale,  # see #locale_options for supported locales
    :theme,   # see app/stylesheets/spry_themes
    :masonry, # boolean, use masonry in storefront products view
    :card_image_type, # image type to use for cover images on cards etc.
    :list_image_type, # image type in list views
    :allow_shopping,  # boolean, master switch to allow/disallow shopping
    :b2b_sales,       # boolean, does the shop do business to business sales
    :admit_guests,    # boolean, are guests allowed to shop at the store
    :shipping_cost_product_id,  # product reference for shipping cost
    :free_shipping_at,  # order total beyond which shipping cost won't apply
    :tracking_code,   # Google Analytics code
    :tawkto_site_id, # tawk.to site id for chat widget
    :froala_key,    # Froala license key
    :pbw_api_key,     # Paybyway API key
    :pbw_private_key, # Paybyway private key
    :order_sequence # base value for order numbers if no numbering exists
  ], coder: JSON

  resourcify
  include Authority::Abilities
  include Imageable

  #---
  after_create :assign_slug

  #---
  has_many :categories
  has_many :products
  has_many :properties
  has_many :orders
  has_many :users
  has_many :pages
  has_many :albums
  has_and_belongs_to_many :inventories
  has_many :order_types, through: :inventories
  has_many :promotions

  scope :all_except, -> (this) { where.not(id: this) }

  #---
  validates :name, presence: true
  validates :host, presence: true
  validates :erp_number, numericality: true, allow_blank: true

  #---
  def self.locale_options
    [['English', 'en'], ['Deutsch', 'de'], ['suomi', 'fi']]
  end

  #---
  # Defaults for guest users reveal pricing and will allow shopping
  # if admit_guests is also enabled, to get in without authentication.
  def guest_user_defaults
    name = "#{Time.now.to_i}#{rand(100)}"
    {
      name: name,
      email: "#{name}@#{host}",
      group: User.groups[:guest],
      roles: Role.where(name: 'see_pricing')
    }
  end

  # Performs an inventory valuation of items in the shipping inventory.
  def inventory_valuation
    items = inventory_for(:shipping).inventory_items
              .for_products(products.live)
    [items, items.map { |item| item.total_value }.sum]
  end

  # Finds the first inventory by purpose.
  def inventory_for(purpose)
    inventories.by_purpose(purpose)
  end

  # Properties flagged searchable.
  def searchable_properties
    properties.merge(Property.searchable).merge(Property.sorted)
  end

  # Available categories at top level.
  def top_level_category_options(exclude = nil)
    (categories.top_level.sorted - [exclude]).map { |c| [c.name, c.id] }
  end

  def category_options
    categories.sorted.map { |c| [c.indented_name, c.id] }
  end

  def user_options
    users.map { |u| [u.to_s, u.id] }
  end

  def page_options
    pages.map { |p| [p.to_s, p.id] }
  end

  def album_options
    albums.map { |a| [a.to_s, a.id] }
  end

  # Finds the shipping cost product manually due to having
  # shipping_cost_product_id a setting instead of a real relation.
  def shipping_cost_product
    if shipping_cost_product_id.present?
      Product.find(shipping_cost_product_id)
    else
      nil
    end
  end

  # Defines accessors to boolean settings not generated by Rails.
  %w[masonry allow_shopping admit_guests b2b_sales].each do |method|
    alias_method "#{method}?", method
    define_method("#{method}=") do |value|
      super(['1', 1, true].include?(value))
    end
  end

  def correspondents
    users.with_role(:correspondence)
  end

  def to_s
    name
  end

  private
    def assign_slug
      taken_slugs = Store.all_except(self).map(&:slug)
      len = 3
      unique_slug = "#{name}#{id}#{Time.now.to_i}"
        .parameterize.underscore.mb_chars.downcase
      begin
        slug = unique_slug[0, len]
        len += 1
      end while taken_slugs.include?(slug)
      update(slug: slug)
    end
end
